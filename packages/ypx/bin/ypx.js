#!/usr/bin/env node
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.argv = void 0;

var _index = _interopRequireDefault(require("../index"));

var _util = require("util");

var _yargs = _interopRequireDefault(require("yargs"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _updateNotifier = _interopRequireDefault(require("@yarn-tool/update-notifier"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

let inputArgv = process.argv.slice(2);
(0, _updateNotifier.default)([__dirname, '..']);
let argv = (0, _yargs.default)(inputArgv).parserConfiguration({
  'populate--': true
}).example(`$0 mocha`, ``).example(`$0 -p esm ts-node mocha -- -r esm`, ``).option('package', {
  desc: `define the package to be installed`,
  alias: 'p',
  array: true,
  string: true
}).option('quiet', {
  desc: `Suppressed any output from npx itself (progress bars, error messages, install reports)`,
  alias: 'q',
  boolean: true
}).option('ignoreExisting', {
  desc: `skip check packages exists or not`,
  boolean: true,
  conflicts: ['noInstall']
}).option('noInstall', {
  desc: `skip install packages`,
  boolean: true
}).option('preferOffline', {
  desc: `use network only if dependencies are not available in local cache`,
  boolean: true
}).option('debugBin', {
  desc: `for cli test only`,
  boolean: true
}).help(`h`).showHelpOnFail(true).argv;
exports.argv = argv;

if (argv.debugBin) {
  console.log(__filename);
  process.exit();
}

let {
  p = []
} = argv;

if (!p || !p.length) {
  if (argv._.length !== 1) {
    throw new Error(`current not support this syntax, ${(0, _util.inspect)(argv)}`);
  } else {
    p = [argv._.shift()];
  }
}

if (argv._.length && argv['--'].length) {
  throw new Error(`current not support this syntax, ${inputArgv}`);
}

_bluebird.default.resolve((0, _index.default)({ ...argv,
  package: p
}, inputArgv)).tapCatch(e => {});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInlweC50cyJdLCJuYW1lcyI6WyJpbnB1dEFyZ3YiLCJwcm9jZXNzIiwiYXJndiIsInNsaWNlIiwiX19kaXJuYW1lIiwicGFyc2VyQ29uZmlndXJhdGlvbiIsImV4YW1wbGUiLCJvcHRpb24iLCJkZXNjIiwiYWxpYXMiLCJhcnJheSIsInN0cmluZyIsImJvb2xlYW4iLCJjb25mbGljdHMiLCJoZWxwIiwic2hvd0hlbHBPbkZhaWwiLCJkZWJ1Z0JpbiIsImNvbnNvbGUiLCJsb2ciLCJfX2ZpbGVuYW1lIiwiZXhpdCIsInAiLCJsZW5ndGgiLCJfIiwiRXJyb3IiLCJzaGlmdCIsIkJsdWViaXJkIiwicmVzb2x2ZSIsInBhY2thZ2UiLCJ0YXBDYXRjaCIsImUiXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7QUFFQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7OztBQUVBLElBQUlBLFNBQVMsR0FBR0MsT0FBTyxDQUFDQyxJQUFSLENBQWFDLEtBQWIsQ0FBbUIsQ0FBbkIsQ0FBaEI7QUFFQSw2QkFBZSxDQUFDQyxTQUFELEVBQVksSUFBWixDQUFmO0FBRU8sSUFBSUYsSUFBSSxHQUFHLG9CQUFNRixTQUFOLEVBQ2hCSyxtQkFEZ0IsQ0FDSTtBQUNwQixnQkFBYztBQURNLENBREosRUFJaEJDLE9BSmdCLENBSVAsVUFKTyxFQUlLLEVBSkwsRUFLaEJBLE9BTGdCLENBS1AsbUNBTE8sRUFLOEIsRUFMOUIsRUFNaEJDLE1BTmdCLENBTVQsU0FOUyxFQU1FO0FBQ2xCQyxFQUFBQSxJQUFJLEVBQUcsb0NBRFc7QUFFbEJDLEVBQUFBLEtBQUssRUFBRSxHQUZXO0FBR2xCQyxFQUFBQSxLQUFLLEVBQUUsSUFIVztBQUlsQkMsRUFBQUEsTUFBTSxFQUFFO0FBSlUsQ0FORixFQVloQkosTUFaZ0IsQ0FZVCxPQVpTLEVBWUE7QUFDaEJDLEVBQUFBLElBQUksRUFBRyx3RkFEUztBQUVoQkMsRUFBQUEsS0FBSyxFQUFFLEdBRlM7QUFHaEJHLEVBQUFBLE9BQU8sRUFBRTtBQUhPLENBWkEsRUFpQmhCTCxNQWpCZ0IsQ0FpQlQsZ0JBakJTLEVBaUJTO0FBQ3pCQyxFQUFBQSxJQUFJLEVBQUcsbUNBRGtCO0FBRXpCSSxFQUFBQSxPQUFPLEVBQUUsSUFGZ0I7QUFHekJDLEVBQUFBLFNBQVMsRUFBRSxDQUFDLFdBQUQ7QUFIYyxDQWpCVCxFQXNCaEJOLE1BdEJnQixDQXNCVCxXQXRCUyxFQXNCSTtBQUNwQkMsRUFBQUEsSUFBSSxFQUFHLHVCQURhO0FBRXBCSSxFQUFBQSxPQUFPLEVBQUU7QUFGVyxDQXRCSixFQTBCaEJMLE1BMUJnQixDQTBCVCxlQTFCUyxFQTBCUTtBQUN4QkMsRUFBQUEsSUFBSSxFQUFHLG1FQURpQjtBQUV4QkksRUFBQUEsT0FBTyxFQUFFO0FBRmUsQ0ExQlIsRUE4QmhCTCxNQTlCZ0IsQ0E4QlQsVUE5QlMsRUE4Qkc7QUFDbkJDLEVBQUFBLElBQUksRUFBRyxtQkFEWTtBQUVuQkksRUFBQUEsT0FBTyxFQUFFO0FBRlUsQ0E5QkgsRUFrQ2hCRSxJQWxDZ0IsQ0FrQ1YsR0FsQ1UsRUFtQ2hCQyxjQW5DZ0IsQ0FtQ0QsSUFuQ0MsRUFvQ2hCYixJQXBDSzs7O0FBdUNQLElBQUlBLElBQUksQ0FBQ2MsUUFBVCxFQUNBO0FBQ0NDLEVBQUFBLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxVQUFaO0FBQ0FsQixFQUFBQSxPQUFPLENBQUNtQixJQUFSO0FBQ0E7O0FBRUQsSUFBSTtBQUFFQyxFQUFBQSxDQUFDLEdBQUc7QUFBTixJQUFhbkIsSUFBakI7O0FBSUEsSUFBSSxDQUFDbUIsQ0FBRCxJQUFNLENBQUNBLENBQUMsQ0FBQ0MsTUFBYixFQUNBO0FBQ0MsTUFBSXBCLElBQUksQ0FBQ3FCLENBQUwsQ0FBT0QsTUFBUCxLQUFrQixDQUF0QixFQUNBO0FBQ0MsVUFBTSxJQUFJRSxLQUFKLENBQVcsb0NBQW1DLG1CQUFRdEIsSUFBUixDQUFjLEVBQTVELENBQU47QUFDQSxHQUhELE1BS0E7QUFDQ21CLElBQUFBLENBQUMsR0FBRyxDQUFDbkIsSUFBSSxDQUFDcUIsQ0FBTCxDQUFPRSxLQUFQLEVBQUQsQ0FBSjtBQUNBO0FBQ0Q7O0FBRUQsSUFBSXZCLElBQUksQ0FBQ3FCLENBQUwsQ0FBT0QsTUFBUCxJQUFpQnBCLElBQUksQ0FBQyxJQUFELENBQUosQ0FBV29CLE1BQWhDLEVBQ0E7QUFDQyxRQUFNLElBQUlFLEtBQUosQ0FBVyxvQ0FBbUN4QixTQUFVLEVBQXhELENBQU47QUFDQTs7QUFFRDBCLGtCQUFTQyxPQUFULENBQWlCLG9CQUFJLEVBQ25CLEdBQUd6QixJQURnQjtBQUVuQjBCLEVBQUFBLE9BQU8sRUFBRVA7QUFGVSxDQUFKLEVBR2JyQixTQUhhLENBQWpCLEVBSUU2QixRQUpGLENBSVdDLENBQUMsSUFBSSxDQUVkLENBTkYiLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG5cbmltcG9ydCBZUFggZnJvbSAnLi4vaW5kZXgnO1xuaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gJ3V0aWwnXG5pbXBvcnQgeyBJWVBYQXJndW1lbnRzIH0gZnJvbSAnLi4vbGliL3R5cGVzJztcbmltcG9ydCB5YXJncyBmcm9tICd5YXJncydcbmltcG9ydCBCbHVlYmlyZCBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgdXBkYXRlTm90aWZpZXIgZnJvbSAnQHlhcm4tdG9vbC91cGRhdGUtbm90aWZpZXInO1xuXG5sZXQgaW5wdXRBcmd2ID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xuXG51cGRhdGVOb3RpZmllcihbX19kaXJuYW1lLCAnLi4nXSk7XG5cbmV4cG9ydCBsZXQgYXJndiA9IHlhcmdzKGlucHV0QXJndilcblx0LnBhcnNlckNvbmZpZ3VyYXRpb24oe1xuXHRcdCdwb3B1bGF0ZS0tJzogdHJ1ZSxcblx0fSlcblx0LmV4YW1wbGUoYCQwIG1vY2hhYCwgYGApXG5cdC5leGFtcGxlKGAkMCAtcCBlc20gdHMtbm9kZSBtb2NoYSAtLSAtciBlc21gLCBgYClcblx0Lm9wdGlvbigncGFja2FnZScsIHtcblx0XHRkZXNjOiBgZGVmaW5lIHRoZSBwYWNrYWdlIHRvIGJlIGluc3RhbGxlZGAsXG5cdFx0YWxpYXM6ICdwJyxcblx0XHRhcnJheTogdHJ1ZSxcblx0XHRzdHJpbmc6IHRydWUsXG5cdH0pXG5cdC5vcHRpb24oJ3F1aWV0Jywge1xuXHRcdGRlc2M6IGBTdXBwcmVzc2VkIGFueSBvdXRwdXQgZnJvbSBucHggaXRzZWxmIChwcm9ncmVzcyBiYXJzLCBlcnJvciBtZXNzYWdlcywgaW5zdGFsbCByZXBvcnRzKWAsXG5cdFx0YWxpYXM6ICdxJyxcblx0XHRib29sZWFuOiB0cnVlLFxuXHR9KVxuXHQub3B0aW9uKCdpZ25vcmVFeGlzdGluZycsIHtcblx0XHRkZXNjOiBgc2tpcCBjaGVjayBwYWNrYWdlcyBleGlzdHMgb3Igbm90YCxcblx0XHRib29sZWFuOiB0cnVlLFxuXHRcdGNvbmZsaWN0czogWydub0luc3RhbGwnXSxcblx0fSlcblx0Lm9wdGlvbignbm9JbnN0YWxsJywge1xuXHRcdGRlc2M6IGBza2lwIGluc3RhbGwgcGFja2FnZXNgLFxuXHRcdGJvb2xlYW46IHRydWUsXG5cdH0pXG5cdC5vcHRpb24oJ3ByZWZlck9mZmxpbmUnLCB7XG5cdFx0ZGVzYzogYHVzZSBuZXR3b3JrIG9ubHkgaWYgZGVwZW5kZW5jaWVzIGFyZSBub3QgYXZhaWxhYmxlIGluIGxvY2FsIGNhY2hlYCxcblx0XHRib29sZWFuOiB0cnVlLFxuXHR9KVxuXHQub3B0aW9uKCdkZWJ1Z0JpbicsIHtcblx0XHRkZXNjOiBgZm9yIGNsaSB0ZXN0IG9ubHlgLFxuXHRcdGJvb2xlYW46IHRydWUsXG5cdH0pXG5cdC5oZWxwKGBoYClcblx0LnNob3dIZWxwT25GYWlsKHRydWUpXG5cdC5hcmd2IGFzIElZUFhBcmd1bWVudHNcbjtcblxuaWYgKGFyZ3YuZGVidWdCaW4pXG57XG5cdGNvbnNvbGUubG9nKF9fZmlsZW5hbWUpO1xuXHRwcm9jZXNzLmV4aXQoKTtcbn1cblxubGV0IHsgcCA9IFtdIH0gPSBhcmd2IGFzIHR5cGVvZiBhcmd2ICYge1xuXHRwOiBzdHJpbmdbXSxcbn07XG5cbmlmICghcCB8fCAhcC5sZW5ndGgpXG57XG5cdGlmIChhcmd2Ll8ubGVuZ3RoICE9PSAxKVxuXHR7XG5cdFx0dGhyb3cgbmV3IEVycm9yKGBjdXJyZW50IG5vdCBzdXBwb3J0IHRoaXMgc3ludGF4LCAke2luc3BlY3QoYXJndil9YClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRwID0gW2FyZ3YuXy5zaGlmdCgpXTtcblx0fVxufVxuXG5pZiAoYXJndi5fLmxlbmd0aCAmJiBhcmd2WyctLSddLmxlbmd0aClcbntcblx0dGhyb3cgbmV3IEVycm9yKGBjdXJyZW50IG5vdCBzdXBwb3J0IHRoaXMgc3ludGF4LCAke2lucHV0QXJndn1gKVxufVxuXG5CbHVlYmlyZC5yZXNvbHZlKFlQWCh7XG5cdFx0Li4uYXJndixcblx0XHRwYWNrYWdlOiBwLFxuXHR9LCBpbnB1dEFyZ3YpKVxuXHQudGFwQ2F0Y2goZSA9PiB7XG5cblx0fSlcbjtcbiJdfQ==